package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/spf13/cobra"

	"github.com/filecoin-project/mir/codegen/proto-converter/util/importerutil"
)

var (
	cmd = &cobra.Command{
		Use: "proto-converter [flags] package",
		Short: "proto-converter â€“ modifies the go files generated by protoc in order to " +
			"extend protobuf functionality for the use in Mir framework.",
		Args: cobra.ExactArgs(1),
		RunE: runConverter,
	}

	keepGenerator bool
)

func init() {
	cmd.Flags().BoolVarP(&keepGenerator, "keep-generator", "k", false, "keep the generated generator program")
}

func runConverter(cmd *cobra.Command, args []string) error {
	packagePath := args[0]

	// Get the current working directory.
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("cannot get the working directory: %v", err)
	}

	// Get the list of all structs (i.e., potential message types) in the package.
	structNames, err := getAllTypesInAPackage(packagePath)
	if err != nil {
		return fmt.Errorf("failed to extract message types from package %v: %w", packagePath, err)
	}

	// Create the generator program code.
	generatorProgram, err := writeGeneratorProgram(packagePath, structNames)
	if err != nil {
		return err
	}

	return runInDir(generatorProgram, wd)
}

func writeGeneratorProgram(importPath string, structNames []string) ([]byte, error) {
	var program bytes.Buffer

	err := generatorTemplate.Execute(&program, &generatorInputs{
		ImportPath:  importPath,
		StructNames: structNames,
	})

	if err != nil {
		return nil, err
	}
	return program.Bytes(), nil
}

// Run the program in the given directory.
func runInDir(program []byte, dir string) error {
	// Create a temporary folder for the generator program.
	tmpDir, err := ioutil.TempDir(dir, "proto_converter_tmp_")
	if err != nil {
		return fmt.Errorf("error creating a temporary directory in %v: %v", dir, err)
	}

	// Remove the temporary folder when finished.
	if !keepGenerator {
		defer func() {
			err := os.RemoveAll(tmpDir)
			if err != nil {
				log.Printf("failed to remove the temporary directory %v: %v", tmpDir, err)
			}
		}()
	}

	progSource := "generator.go"
	progBinary := "generator.bin"
	if runtime.GOOS == "windows" {
		// Windows won't execute a program unless it has a ".exe" suffix.
		progBinary += ".exe"
	}

	if err := ioutil.WriteFile(filepath.Join(tmpDir, progSource), program, 0600); err != nil {
		return err
	}

	cmdArgs := []string{"build", "-o", progBinary, progSource}

	// Build the program.
	buildCmd := exec.Command("go", cmdArgs...)
	buildCmd.Dir = tmpDir
	buildCmd.Stdout = os.Stdout
	buildCmd.Stderr = os.Stderr
	if err := buildCmd.Run(); err != nil {
		return err
	}

	// Run the program.
	generatorCmd := exec.Command(path.Join(tmpDir, progBinary))
	generatorCmd.Stdout = os.Stdout
	generatorCmd.Stderr = os.Stderr
	return generatorCmd.Run()
}

func main() {
	err := cmd.Execute()
	if err != nil {
		log.Printf("Error executing the converter: %v\n", err)
		os.Exit(2)
	}
}

func getAllTypesInAPackage(sourcePkgPath string) ([]string, error) {
	// Get the source dir of the package.
	sourceDir, err := importerutil.GetSourceDirForPackage(sourcePkgPath)
	if err != nil {
		return nil, fmt.Errorf("could not obtain the source dir for package %v: %w", sourcePkgPath, err)
	}

	// Parse the source dir.
	fset := token.FileSet{}
	pkgs, err := parser.ParseDir(&fset, sourceDir, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("could not parse the package sources: %v", err)
	}

	// Get the ast of the target package.
	pkgName := sourcePkgPath[strings.LastIndex(sourcePkgPath, "/")+1:]
	pkgAst, ok := pkgs[pkgName]
	if !ok {
		return nil, fmt.Errorf("did not find package %v in %v", pkgName, sourceDir)
	}

	var res []string
	for _, file := range pkgAst.Files {
		for _, decl := range file.Decls {
			decl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range decl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				if typeSpec.Assign != token.NoPos {
					// Ignore type aliases.
					continue
				}

				if !ast.IsExported(typeSpec.Name.Name) {
					// Skip unexported types.
					continue
				}

				if typeSpec.TypeParams != nil {
					// Skip generic types.
					continue
				}

				res = append(res, typeSpec.Name.Name)
			}
		}
	}

	return res, nil
}

type generatorInputs struct {
	ImportPath  string
	StructNames []string
}

var generatorTemplate = template.Must(template.New("generator").Parse(`
package main

import (
	"log"
	"os"
	"reflect"

	"github.com/filecoin-project/mir/codegen/proto-converter/codegen"
	pkg_ "{{.ImportPath}}"
)

func main() {
	err := codegen.GenerateAll(
		"pkg/pb/availabilitypb",
		[]reflect.Type{
			{{range .StructNames}}
			reflect.TypeOf((*pkg_.{{.}})(nil)),
			{{end}}
		})

	if err != nil {
		log.Printf("Error: %v\n", err)
		os.Exit(2)
	}
}
`))
