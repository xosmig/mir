package model

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/filecoin-project/mir/codegen/proto-converter/util/jenutil"
	"github.com/filecoin-project/mir/codegen/proto-converter/util/protoreflectutil"
	"github.com/filecoin-project/mir/pkg/util/sliceutil"
)

type Parser struct {
	cache map[reflect.Type]Type
}

func messageCacheLookup(tp reflect.Type) (*Message, bool) {
	parsedMessagesCache.mutex.Lock()
	defer parsedMessagesCache.mutex.Unlock()

	if parsedMessagesCache.cache == nil {
		parsedMessagesCache.cache = make(map[reflect.Type]*Message)
	}

	msg, ok := parsedMessagesCache.cache[tp]
	return msg, ok
}

func storeMessageInCache(tp reflect.Type, msg *Message) {
	parsedMessagesCache.mutex.Lock()
	defer parsedMessagesCache.mutex.Unlock()

	parsedMessagesCache.cache[tp] = msg
}

func ParseGoTypes(pbGoStructPtrTypes []reflect.Type) ([]*Message, []*OneofOption, error) {
	var msgs []*Message
	var oneofOptions []*OneofOption

	for _, ptrType := range pbGoStructPtrTypes {
		if ptrType.Kind() != reflect.Pointer || ptrType.Elem().Kind() != reflect.Struct {
			return nil, nil, fmt.Errorf("expected a pointer to a struct, got %v", ptrType)
		}

		// Parse messages.
		if IsProtoMessage(ptrType) {
			msg, err := ParseMessage(ptrType)
			if err != nil {
				return nil, nil, err
			}

			msgs = append(msgs, msg)
			continue
		}

		// Parse oneof options
		if IsOneofOption(ptrType) {
			opt, err := ParseOneofOption(ptrType)
			if err != nil {
				return nil, nil, err
			}

			oneofOptions = append(oneofOptions, opt)
		}
	}

	return msgs, oneofOptions, nil
}

func IsProtoMessage(ptrType reflect.Type) bool {
	_, ok := protoreflectutil.DescriptorForType(ptrType)
	return ok
}

func IsOneofOption(ptrType reflect.Type) bool {
	if ptrType.Kind() != reflect.Pointer || ptrType.Elem().Kind() != reflect.Struct || ptrType.Elem().NumField() != 1 {
		// Oneof wrapper is a pointer to a struct with a single field.
		return false
	}

	tag, ok := ptrType.Elem().Field(0).Tag.Lookup("protobuf")
	if !ok {
		return false
	}

	return sliceutil.Index(strings.Split(tag, ","), "oneof") != -1
}

// ParseMessage returns the message corresponding to the given protobuf-generated struct type.
func ParseMessage(pbGoStructPtr reflect.Type) (*Message, error) {
	if msg, ok := messageCacheLookup(pbGoStructPtr); ok {
		return msg, nil
	}

	protoDesc, ok := protoreflectutil.DescriptorForType(pbGoStructPtr)
	if !ok {
		return nil, fmt.Errorf("%T is not a protobuf message", pbGoStructPtr)
	}

	pbStructType := jenutil.QualFromType(pbGoStructPtr.Elem())

	shouldGenerateMirType := ShouldGenerateMirType(protoDesc)

	var pkgPath string
	var mirStructType jen.Code

	if shouldGenerateMirType {
		// The type of the struct that will be generated.
		pkgPath = StructsPackagePath(pbGoStructPtr.Elem().PkgPath())
		mirStructType = jen.Qual(pkgPath, pbGoStructPtr.Elem().Name())
	} else {
		// The original type generated by protoc.
		pkgPath = pbGoStructPtr.Elem().PkgPath()
		mirStructType = pbStructType
	}

	msg := &Message{
		shouldGenerateMirType: shouldGenerateMirType,
		pbStructType:          pbStructType,
		mirStructType:         mirStructType,
		protoDesc:             protoDesc,
		pbGoStructPtrReflect:  pbGoStructPtr,
	}

	storeMessageInCache(pbGoStructPtr, msg)
	return msg, nil
}

func ParseOneofOption(ptrType reflect.Type) (*OneofOption, error) {
	if !IsOneofOption(ptrType) {
		return nil, fmt.Errorf("%v is not a oneof option", ptrType)
	}

	if !IsProtoMessage(ptrType.Elem().Field(0).Type) {
		return nil, fmt.Errorf("currently, only message types are supported in oneof options")
	}

	fieldType, err := ParseMessage(ptrType.Elem().Field(0).Type)
	if err != nil {
		return nil, err
	}

	return &OneofOption{
		PbWrapperReflect: ptrType,
		WrapperName:      ptrType.Elem().Name(),
		Field: &Field{
			Name: ptrType.Elem().Field(0).Name,
			Type: fieldType,
		},
	}, nil
}

func ParseGoIdent(ident string) (packagePath, typeName string) {
	sepIdx := strings.LastIndex(ident, ".")
	return ident[:sepIdx], ident[:sepIdx+1]
}
