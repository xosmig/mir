package model

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/filecoin-project/mir/codegen/proto-converter/util/jenutil"
	"github.com/filecoin-project/mir/codegen/proto-converter/util/protoreflectutil"
	"github.com/filecoin-project/mir/pkg/pb/mir"
)

type Parser struct {
	cache map[reflect.Type]*Message
}

func NewParser() *Parser {
	return &Parser{
		cache: make(map[reflect.Type]*Message),
	}
}

func (p *Parser) ParseMessages(pbGoStructPtrTypes []reflect.Type) ([]*Message, error) {
	var msgs []*Message

	for _, ptrType := range pbGoStructPtrTypes {
		if ptrType.Kind() != reflect.Pointer || ptrType.Elem().Kind() != reflect.Struct {
			return nil, fmt.Errorf("expected a pointer to a struct, got %v", ptrType)
		}

		// Parse messages.
		if protoreflectutil.IsMessageType(ptrType) {
			msg, err := p.ParseMessage(ptrType)
			if err != nil {
				return nil, err
			}

			msgs = append(msgs, msg)
			continue
		}
	}

	return msgs, nil
}

// ParseMessage returns the message corresponding to the given protobuf-generated struct type.
func (p *Parser) ParseMessage(pbGoStructPtr reflect.Type) (*Message, error) {
	if tp, ok := p.cache[pbGoStructPtr]; ok {
		return tp, nil
	}

	protoDesc, ok := protoreflectutil.DescriptorForType(pbGoStructPtr)
	if !ok {
		return nil, fmt.Errorf("%T is not a protobuf message", pbGoStructPtr)
	}

	pbStructType := jenutil.QualFromType(pbGoStructPtr.Elem())

	shouldGenerateMirType := ShouldGenerateMirType(protoDesc)

	var pkgPath string
	var mirStructType jen.Code

	if shouldGenerateMirType {
		// The type of the struct that will be generated.
		pkgPath = StructsPackagePath(pbGoStructPtr.Elem().PkgPath())
		mirStructType = jen.Qual(pkgPath, pbGoStructPtr.Elem().Name())
	} else {
		// The original type generated by protoc.
		pkgPath = pbGoStructPtr.Elem().PkgPath()
		mirStructType = pbStructType
	}

	msg := &Message{
		parser:                p,
		shouldGenerateMirType: shouldGenerateMirType,
		pbStructType:          pbStructType,
		mirStructType:         mirStructType,
		protoDesc:             protoDesc,
		pbGoStructPtrReflect:  pbGoStructPtr,
	}

	p.cache[pbGoStructPtr] = msg
	return msg, nil
}

// parseField extracts the information about the field necessary for code generation.
func (p *Parser) parseField(goField reflect.StructField, protoField protoreflect.FieldDescriptor) (*Field, error) {
	tp, err := p.getFieldType(goField.Type, protoField)
	if err != nil {
		return nil, err
	}

	return &Field{
		Name: goField.Name,
		Type: tp,
	}, nil
}

func (p *Parser) getFieldType(goType reflect.Type, protoField protoreflect.FieldDescriptor) (Type, error) {
	// TODO: Since maps are not currently used, I didn't bother supporting them yet.
	if goType.Kind() == reflect.Map {
		return nil, fmt.Errorf("map fields are not supported yet")
	}

	// Check if the field is repeated.
	if goType.Kind() == reflect.Slice {
		underlying, err := p.getFieldType(goType.Elem(), protoField)
		if err != nil {
			return nil, err
		}
		return Slice{underlying}, nil
	}

	// Check if the field has (mir.type) option specified.
	protoFieldOptions := protoField.Options().(*descriptorpb.FieldOptions)
	mirTypeOption := proto.GetExtension(protoFieldOptions, mir.E_Type).(string)
	if mirTypeOption != "" {
		sepIdx := strings.LastIndex(mirTypeOption, ".")
		return Castable{
			pbType:  jenutil.QualFromType(goType),
			mirType: jen.Qual(mirTypeOption[:sepIdx], mirTypeOption[sepIdx+1:]),
		}, nil
	}

	// Check if the field is a message.
	if protoreflectutil.IsMessageType(goType) {
		msg, err := p.ParseMessage(goType)
		if err != nil {
			return nil, err
		}

		return msg, nil
	}

	return Same{jenutil.QualFromType(goType)}, nil
}
