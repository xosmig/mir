package protoutil

import (
	"fmt"
	"github.com/filecoin-project/mir/pkg/util/reflectutil"
	"reflect"
	"unsafe"
)

// VerifyOneofWrapper verifies that type W is, or structurally identical to, a wrapper around type T generated by the
// protobuf compiler for an element of a "oneof" statement of type T.
// If VerifyOneofWrapper[W,T]() returns nil, then function UnsafeUnwrapOneofWrapper[W, T](...) is safe to execute.
//
// In case of changes to the protobuf API, this function may reject some valid combinations of W and T.
// However, regardless of the changes to the API, the safety of UnsafeUnwrapOneofWrapper[W, T](...) is guaranteed if
// VerifyOneofWrapper[W,T]() returns nil.
//
// TODO: replace with a simple protoc plugin that generates function Unwrap() for the wrapper types.
// 		 Then there will be no need for this function. It will be sufficient to use interface { Unwrap() T } as a type
// 		 restriction on W.
//
// Example:
//   the following protobuf specification:
//       message Bar {}
//       message Foo {
//           oneof bar_or_baz {
//               Bar bar_option = 1;
//               uint64 baz_option = 2;
//           }
//       }
//   will cause protoc-gen-go to generate 4 types: Bar, Foo, Foo_BarOption, and Foo_BazOption.
//   Then VerifyOneofWrapper[Foo_BarOption, *Bar]() and VerifyOneofWrapper[Foo_BazOption, uint64]() will return nil.
func VerifyOneofWrapper[W, T any]() error {
	wType := reflectutil.TypeOf[W]()
	tType := reflectutil.TypeOf[T]()
	genericWrapperType := reflectutil.TypeOf[genericOneofWrapper[T]]()

	if wType.Kind() != reflect.Struct || wType.NumField() != 1 {
		return fmt.Errorf("%s is supposed to be a struct with a single field of type %s", wType.Name(), tType.Name())
	}
	if wType.Field(0).Type != tType {
		return fmt.Errorf("%s is supposed to be a struct with a single field of type %s", wType.Name(), tType.Name())
	}
	if wType.Size() != genericWrapperType.Size() || wType.Align() != genericWrapperType.Align() {
		return fmt.Errorf("unexpected size or alignment for type %s", wType.Name())
	}
	if wType.Field(0).Offset != genericWrapperType.Field(0).Offset {
		return fmt.Errorf("unexpected field offset for type %s", wType.Name())
	}

	return nil
}

// UnsafeUnwrapOneofWrapper returns the underlying object from a wrapper generated by the protobuf compiler.
// It is only safe to invoke if VerifyOneofWrapper[W, T]() == nil. Otherwise, it may lead to undefined behaviour and
// memory corruption.
func UnsafeUnwrapOneofWrapper[W, T any](w *W) T {
	return (*genericOneofWrapper[T])(unsafe.Pointer(w)).t
}

type genericOneofWrapper[T any] struct{ t T }
