package dsl

import (
	"fmt"
	"github.com/filecoin-project/mir/pkg/events"
	"github.com/filecoin-project/mir/pkg/pb/eventpb"
	"github.com/filecoin-project/mir/pkg/util"
	"reflect"
	"unsafe"
)

// Module allows creating passive modules in a very natural declarative way.
type Module struct {
	eventHandlers     map[reflect.Type]func(ev *eventpb.Event) (*events.EventList, error)
	conditionHandlers []conditionEntry
}

func NewModule() *Module {
	return &Module{}
}

type conditionEntry struct {
	condition func() bool
	handler   func() (*events.EventList, error)
}

type evContainer[Ev any] struct{ ev *Ev }

// UponEvent registers an event handler for module `m`.
// This event handler will be called every time an event of type `EvTp` is received.
// Type `EvTp` must be a wrapper around `Ev` generated by the protobuf framework.
// Note that the type parameter `Ev` can be inferred automatically from `handler`.
func UponEvent[EvTp, Ev any](m *Module, handler func(ev *Ev) (*events.EventList, error)) {
	evTpType := util.TypeOf[EvTp]()
	evType := util.TypeOf[Ev]()
	evContainerType := util.TypeOf[evContainer[Ev]]()

	if _, ok := m.eventHandlers[evType]; ok {
		panic(fmt.Sprintf("Event handler for event type %s is already registered.", evTpType.Name()))
	}

	m.eventHandlers[evTpType] = func(ev *eventpb.Event) (*events.EventList, error) {
		evTp := ev.Type.(EvTp)
		// The safety of this cast is verified by the runtime checks below.
		evTpPtr := (*evContainer[Ev])(unsafe.Pointer(&evTp))
		return handler((*evTpPtr).ev)
	}

	// These checks verify that an object of type EvTp can be safely interpreted as object of type evContainer[Ev].
	// They are only performed at the time of registration of the handler (which is supposedly at the very beginning
	// of the program execution) and make sure that no unexpected runtime errors will happen during later stages
	// of protocol execution and no memory will be corrupted by the pointer cast between (*EvTp) and (*evContainer[Ev]).
	// These checks may fail in case of a change to the protobuf API or when erroneous type parameters (EvTp and Ev) are
	// provided.
	const explanationStr = "Most likely, the function was called with an invalid combination of type parameters. " +
		"This error may also be caused by a change to the API of the protobuf implementation."
	if evTpType.Kind() != reflect.Struct || evTpType.NumField() != 1 {
		panic(fmt.Sprintf("%s is supposed to be a struct with a single field of type *%s. %s",
			evTpType.Name(), evType.Name(), explanationStr))
	}
	if evTpType.Field(0).Type.Kind() != reflect.Pointer || evTpType.Field(0).Type.Elem() != evType {
		panic(fmt.Sprintf("%s is supposed to be a struct with a single field of type *%s. %s",
			evTpType.Name(), evType.Name(), explanationStr))
	}
	if evTpType.Field(0).Name != evType.Name() {
		panic(fmt.Sprintf("Unexpected field name for type %s. Expected '%s', got '%s'. %s",
			evTpType.Name(), evType.Name(), evTpType.Field(0).Name, explanationStr))
	}
	if evTpType.Field(0).Offset != evContainerType.Field(0).Offset {
		panic(fmt.Sprintf("Unexpected field offset for type %s. %s",
			evTpType.Name(), explanationStr))
	}
	if evTpType.Size() != evContainerType.Size() || evTpType.Align() != evContainerType.Align() {
		panic(fmt.Sprintf("Unexpected size or alignment for type %s. %s",
			evTpType.Name(), explanationStr))
	}
}

// UponRepeatedCondition registers a *repeated* condition handler. Predicate `cond` will be evaluated each time after a
// batch of events is processed and *each time* `cond()` returns `True`, `handler` will be invoked.
// Conditions are checked in the order of their registration.
func UponRepeatedCondition(m *Module, cond func() bool, handler func() (*events.EventList, error)) {
	m.conditionHandlers = append(m.conditionHandlers, conditionEntry{
		condition: cond,
		handler:   handler,
	})
}

// UponOneShotCondition registers a *one-shot* condition handler. Predicate `cond` will be evaluated each time after a
// batch of events is processed until it returns `true`. After `cond()` returns `true` *for the first time*  `cond()`,
// `handler` will be invoked.
// Conditions are checked in the order of their registration.
func UponOneShotCondition(m *Module, cond func() bool, handler func() (*events.EventList, error)) {
	fired := false
	UponRepeatedCondition(m, func() bool { return !fired && cond() }, func() (*events.EventList, error) {
		fired = true
		return handler()
	})
}

// The ImplementsModule method only serves the purpose of indicating that this is a Module and must not be called.
func (m *Module) ImplementsModule() {}

func (m *Module) ApplyEvents(evs *events.EventList) (*events.EventList, error) {
	outputEvents := &events.EventList{}

	// Run event handlers.
	iter := evs.Iterator()
	for ev := iter.Next(); ev != nil; ev = iter.Next() {
		handler, ok := m.eventHandlers[reflect.TypeOf(ev.Type)]
		if !ok {
			return nil, fmt.Errorf("unknown event type '%T'", ev.Type)
		}

		output, err := handler(ev)
		if err != nil {
			return nil, err
		}

		outputEvents.PushBackList(output)
	}

	// Run condition handlers.
	for _, condEntry := range m.conditionHandlers {
		if condEntry.condition() {
			output, err := condEntry.handler()

			if err != nil {
				return nil, err
			}

			outputEvents.PushBackList(output)
		}
	}

	return outputEvents, nil
}
